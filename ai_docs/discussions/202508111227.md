# Fix Duplicate Speech Recording Issue

**Date:** 2025-08-11  
**Issue:** Speech-to-text recording was duplicating text in the editor  
**Solution:** Implemented useTranscriptRef pattern to prevent duplicate speech recognition instances

## Problem Analysis

The duplicate speech recording issue was caused by:

1. **Multiple Speech Recognition Instances**: The `useRealtimeTranscription` hook was recreating speech recognition instances on every re-render due to callback dependencies
2. **Stale Closures**: Component re-renders created new `onTranscript` functions, but existing speech recognition listeners were still calling old versions
3. **Interim vs Final Text Handling**: Both interim and final transcripts were being permanently added to the editor content

## Root Cause

In the original implementation, the useEffect dependency array included `[onTranscript, onError]`, causing:
- New speech recognition instance creation on every callback change
- Multiple listeners processing the same speech
- Text appearing multiple times in the editor

## Solution: useTranscriptRef Pattern

### 1. Ref-Based Callback Storage
```typescript
const onTranscriptRef = useRef(onTranscript);
const onErrorRef = useRef(onError);

// Update refs when callbacks change
useEffect(() => {
  onTranscriptRef.current = onTranscript;
}, [onTranscript]);
```

### 2. Single Instance Creation
```typescript
useEffect(() => {
  // Speech recognition setup
  recognition.onresult = (event) => {
    // Always calls the latest callback via ref
    onTranscriptRef.current?.(text, isFinal);
  };
}, []); // Empty dependency array - setup only once
```

### 3. Proper Interim/Final Handling
```typescript
if (isFinal) {
  // Use base content (before interim) as starting point
  const baseContent = baseContentRef.current || editor?.getText() || '';
  const newContent = baseContent + separator + text;
  editor?.commands.setContent(newContent);
  baseContentRef.current = ''; // Reset for next speech segment
} else {
  // Show interim preview without permanent storage
  const tempContent = baseContentRef.current + separator + text;
  editor?.commands.setContent(tempContent);
}
```

## Implementation Details

### Files Modified
- `src/hooks/use-realtime-transcription.ts` - Added ref pattern for callbacks
- `src/components/TextEditor.tsx` - Fixed interim/final transcript handling

### Key Changes
1. **Refs for Callbacks**: `onTranscriptRef` and `onErrorRef` to avoid stale closures
2. **Empty Dependency Array**: Speech recognition instance created only once
3. **Base Content Tracking**: Proper separation of interim preview and final text
4. **Content Reset**: Clear `baseContentRef` after final transcript processing

### Flow Documentation
Created detailed flow documents in `/flows/`:
- `recording-flow.md` - Complete recording process from click to text
- `recording-button-speech-flow.md` - Focused flow after record button click

## Testing & Verification

### Before Fix
```
User speaks "hello"
→ Interim: "hello" added to editor
→ Final: "hello" added again to editor
→ Result: "hello hello" (duplicate)
```

### After Fix
```
User speaks "hello"
→ Interim: "hello" shown as preview (baseContentRef tracks original)
→ Final: "hello" added to original content, baseContentRef reset
→ Result: "hello" (single instance)
```

### Debug Logs
Added targeted logging to track the fix:
- `[Final text] Calling onTranscript with: [text]` - Hook calling editor
- `[TextEditor onTranscript] Received: [text] isFinal: [boolean]` - Editor receiving call

## Technical Benefits

1. **Performance**: Single speech recognition instance per component
2. **Memory**: No duplicate event listeners or recognition objects
3. **Reliability**: Consistent behavior across component re-renders
4. **User Experience**: Clean, accurate speech-to-text without duplicates

## Build & Deployment

- ✅ Build passed with `pnpm build`
- ✅ Changes committed and merged to main branch
- ✅ No breaking changes or regressions introduced

The fix successfully resolves the duplicate speech recording issue using a clean, maintainable pattern that ensures optimal performance and user experience.